class LRUCache {
public:

class Node{
    public:
    int key,val;
    Node* prev;;
    Node*  next;

    Node(int k,int v){
        key=k;
        val=v;
    }

};

Node* head=new Node(-1,-1);
Node* tail=new Node(-1,-1);
int limit;
unordered_map<int,Node*>m;

void addNode(Node* newNode){
    Node*oldNext=head->next;

    head->next=newNode;
    oldNext->prev=newNode;

    newNode->next=oldNext;
    newNode->prev=head;
}

void delNode(Node* oldNode){
    Node* oldPrev=oldNode->prev;
    Node* oldNext=oldNode->next;

    oldPrev->next=oldNext;
    oldNext->prev=oldPrev;
}
    LRUCache(int capacity) {
        limit=capacity;
        head->next=tail;
        tail->prev=head;
    }
    
    int get(int key) {
        if(m.find(key)==m.end()){
            return -1;
        }

        Node* ansNode=m[key];
        int ans=ansNode->val;

        m.erase(key);
        delNode(ansNode);

        addNode(ansNode);
        m[key]=ansNode;

        return ans;
    }
    
    void put(int key, int value) {
        if(m.find(key)!=m.end()){

            Node* oldNode=m[key];
            delNode(oldNode);
            m.erase(key);

        }
        if(m.size()==limit){
            m.erase(tail->prev->key);
            delNode(tail->prev);
        }

        Node* newNode=new Node(key,value);
        addNode(newNode);
        m[key]=newNode;
    }
};



// vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> dq;
        vector<int>res;
 
 //1st window
        for(int i=0;i<k;i++){
          while(!dq.empty()&&nums[dq.front()]<=nums[i]){
            dq.pop_back();
          }  
          dq.push_back(i);
        }


        //other windows
        for(int i=k;i<nums.size();i++){
            res.push_back(nums[dq.front()]);
            //wrong element in the window
            while(!dq.empty()&&dq.front()<=i-k){
                dq.pop_front();
            }

            //delete smaller val
              while(!dq.empty()&&nums[dq.front()]<=nums[i]){
            dq.pop_back();
          }  

          dq.push_back(i);
        }

        res.push_back(nums[dq.front()]);
         

         return res;